# Windows Architecture
A processor inside a machine running the Windows operating system can operate under 2 different modes:
1. User Mode
2. Kernel Mode
Applications run in user mode, and operating system components run in kernel mode.
When an application wants to accomplish a task such as creating a file, it cannot do so by its own. The only entity that can complete the task is the kernel, so instead applications must follow a specific function call flow.
EXAMPLE
![[intro_windows_architecture.png]]
- User Processes
	- A program/application executed by the user such as Notepad, Google Chrome or Microsoft Word.
- Subsystem DLLs
	- DLLs that contain API functions that are called by a user processes.
	- EXAMPLES
		- kernel32.dll (exporting the CreateFile Windows API (WinAPI) function)
		- ntdl.dll
		- advapi32.dll
		- user32.dll
- Ntdl.dll
	- A system-wide DLL which is the lowest layer available in user mode
	- This is a special DLL that creates the transition from user mode to kernel mode.
	- Often referred to as the Native API or NTAPI
- Executive Kernel
	- This is what is known as the Windows Kernel and it calls other drivers and modules available within kernel mode to complete tasks.
	- The Windows kernel is partially stored in a file called "ntoskrnl.exe" under "C:\Windows\System32"
## Function call flow
The image below shows an example of an application that creates a file.
1. User application calling the CreateFile WinAPI function which is available in "kernel32.dll".
	1. Kernel32.dll is a critical DLL that exposes applications to the WinAPI and is therefore can be seen loaded by most applications.
2. CreateFile calls its equivalent NTAPI function, "NtCreateFile" which is provided through "ntdll.dll"
3. "Ntdll.dll" executes an assembly "sysenter (x86)" or "syscall (x64)" instruction.
	1. this transfers execution to kernel mode.
4. Kernel "NtCreateFile" function is then used which calls kernel drivers and modules to perform the requested task.
![[function_flow_call_1.png]]
EXAMPLE
- This shows the function call flow happening through a debugger. this is done by attaching a debugger to a binary that creates a file via the CreateFileW Windows API.
- the user application calls the CreateFileW WinAPI
![[createfilew.png]]
- CreateFileW calls its equivalent NTAPI function, NtCreateFile
![[ntcreatefile-dbg.png]]
- the NtCreateFile function uses a syscall assembly instruction to transition from user mode to kernel mode.
- the kernel will then be the one that creates the file. 
![[syscall.png]]
## Directly invoking the Native API (NTAPI)
It's important to note that applications can invoke syscalls (i.e. NTDLL functions) directly without having to go through the Windows API. The Windows API simply acts as a wrapper for the Native API. With that being said, the Native API is more difficult to use because it is not officially documented by Microsoft. Furthermore, Microsoft advises against the use of the Native API functions because they can be changed at any time without warning.