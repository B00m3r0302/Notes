#  Introduction
Both .exe and .dll file fypes are considered portable executable formats but there are differences between the two.
## What is a DLL?
DLLs are shared libraries of executable functions or data that can be used by multiple applications simultaneously. They are used to export functions to be used by a process. Unlike EXE files, DLL files cannot execute code on their own. Instead, DLL libraries nee to be invoked by other programs to execute the code. As previously mentioned, the "CreateFileW" is exported from "Kernel32.dll", therefore if a process wants to call that function it would first need to load "kernel32.dll" into its address space.

Some DLLs are automatically loaded into every process by default since these DLLs export functions that are necessary for the process to execute properly. A few examples of these DLLs are 
- ntdl.dll
- kernel32.dll
- kernelbase.dll
The image below shows several DLLs that are currently loaded by the explorer.exe process
![[loaded-libraries.png]]

# System-Wide DLL Base Address
The Windows OS uses a system-wide DLL base address to load some DLLs at the same base address in the virtual address space of all processes on a given machine to optomize memory usage and improve system performance.
The image below shows "kernel32.dll" being loaded at the same address "(0x7fff9fad0000)" among multiple running processes.
![[dll-new.png]]
# Why use DLLs?
There are several reasons why DLLs are very often used in Windows:
- Modularization of code
	- Instead of having one massive executable that contains the entire functionality, the code is divided into several indepenednt libraries with each library being focused on specific functionality. Modularization makes it easier for developers during development and debugging.
- Code reuse
	- DLLs promote code reuse since a library can be invoked by multiple processes.
- Efficient memory usage
	- When several processes need the same DLL, they can save memory by sharing that DLL instead of loading it into the process memory.
# Creating a DLL file within Visual Studio
To create a DLL file, launch Visual Studio and create a new project. When given the project templates, select the "Dynamic-Link Library (DLL)" option.
![[create-dll-1.png]]
Next, select the location where you will save the project files. When the project has been saved, "dllmain.cpp" should appear with the default DLL code.
![[create-dll-2.png]]
# DLL Entry Point
Recall that DLLs are loaded by applications. Therefore, DLLs can specify an entry point function that executes code when a certain action occurs. There are 4 possibilities for the entry point being callec:
- DLL_PROCESS_ATTACH
	- A process is loading the dll
- DLL_THREAD_ATTACH
	- A process is creating a new thread
- DLL_THREAD_DETACH
	- A thread exits normally
- DLL_PROCESS_DETACH
	- A process unloads the DLL
# Exporting a Function
DLLs can export functions that can be used by the calling application. To export a function it needs to defined using the keywords "extern" and "__declspec(dllexport)". An example exported function "HelloWorld" is shown in the "sampleDLL.dll" file below.
```c
#include <Windows.h>

// Exported function
extern __declspec(dllexport) void HelloWorld() {
	MessageBoxA(NULL, "Hello, World!", "DLL Message", MBICONINFORMATION);
}

// Entry point for the dll
BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
	switch (ul_reason_for_call) {
		case DLL_PROCESS_ATTACH:
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break,
	}
	return TRUE;
}
```
- "HelloWorld" can now be invoked by an external application after loading "sampleDLL.dll" into memory,
# Dynamic Linking
It's possible to use the "LoadLibrary", "GetModuleHandle", and "GetProcAddress" WinAPIs to import a function from a DLL. This is referred to as *Dynamic linking*. This is a method of loading and linking code (DLLs) at runtime rather than linking them at compile time using the linker and import address table. There are several advantages of using dynamic linking; they are documented at the link below.
- https://learn.microsoft.com/en-us/windows/win32/dlls/advantages-of-dynamic-linking
## Step 1 - Loading a DLL
We're going to switch an EXE file in this step and the steps that follow. This is because our EXE file will be the one loading "sampleDLL.dll" and invoking the "HelloWorld" function. Therefore, create a new Win32 Console Application and follow along to invoke "HelloWorld"

Calling a function such as *MessageBoxA* in an application will force the Windows OS to load the DLL exporting the "MessageBoxA" function into the calling processes's memory address space, which in this case is "user32.dll". Loading "user32.dll" was done automatically by the OS when the process started and not by the code.

However, for custom DLLs such as our "sampleDLL.dll", the DLL will not be loaded into memory. Since the application doesn't habe "sampleDLL.dll" loaded into memory, it would require the usage of the *LoadLibrary* WinAPI, as shown below
```c
#include <windows.h>

int main() {
	// Load the DLL
	HMODULE hModule = LoadLibraryA("sampleDLL.dll"); // hModule now contains sampleDLL.dll's handle
	
}
```

## Step 2 - Retrieving a DLL's Handle
Had "sampleDLL.dll" been already loaded into the application's memory, one can retrieve its handle via the *GetModuleHandle* WinAPI function without leveraging the "LoadLibrary" function.
```c
#include <windows.h>

int main() {

	// Attempt to get the handle of the DLL that's already in memory
	HMODULE hModule = GetModuleHandleA("sampleDLL.dll");

	if (hModule == NULL) {
		// If the DLL is not loaded in memory, use LoadLibrary to load it
		hModule = LoadLibraryA("sampleDLL.dll");
	}
}
```
## Step 3 - Type-casting The Function's Address
Once "HelloWorld"'s address is saved into the "pHelloWorld" variable, the next step is to perform a type-cast on this address to "HelloWorld"'s function pointer. This function pointer is required in order to invoke the function.
```c
#include <windows.h>

// Constructing a new data type that represents HelloWorld's function pointer 
typedef void (WINAPI* HelloWorldFunctionPointer) ();

int main () {
	// Attempt to get the handle of the DLL
	HMODULE hModule = GetModuleHandleA("sampleDLL.dll");

	if (hModule == NULL) {
		// If the DLL is not loaded in memory, use LoadLibrary to load it
		hModule = LoadLibraryA("sampleDLL.dll");
	}

	PVOID pHelloWorld = GetProcAddress(hModule, "HelloWorld"); /// pHelloWorld stores HelloWorld's function address

	HelloWorldFunctionPointer HelloWorld = (HelloWorldFunctionPointer)pHelloWorld;

	return 0;
}
```
## Putting It Together - Invoking HelloWorld
This section will now put all the aforementioned steps into one function, called "call()". The function will essentially perform the following steps:
1. Load "sampleDLL.dll"
2. Retrieve the "HelloWorld" function's address
3. Type-cast "HelloWorld"
4. Invoke "HelloWorld"
Again, this fuction is being called from our exe program as it is the one loading the DLL and invoking the "HelloWorld" function.
```c
#include <windows.h>

// Constructing a new data type that represents HelloWorld's functionpointer
typedef void (WINAPI* HelloWorldFunctionPointer) ();

void call() {
	// Attempt to get the handle of the DLL
	HMODULE hModule = GetModuleHandleA("samoleDLL.dll");

	if (hModule == NULL) {
		// If the DLLis not loaded in memory, we use LoadLibrary to load it
		hModule = LoadLibraryA("sampleDLL.dll");
	}

	// pHelloWorld stores HelloWorld's function address
	PVOID pHelloWorld = GetProcAddress(hModule, "HelloWorld");

	// Typecasting pHelloWorld to be of type HelloWorldFunctionPointer
	HelloWorldFunctionPointer HelloWorld = (HelloWorldFunctionPointer)pHelloWorld;


	// Invoke HelloWorld
	HelloWorld();
}

int main() {

	call(); // Invoke the call() function

	return 0;
}
```

# Dynamic Linking Example - MessageBoxA
The code below demonstrates another simple example of dynamic linking where "MessageBoxA" is called. The code assumes that "user32.dll", the DLL that exports that function isn't loaded into memory. Recall that if a DLL isn't loaded into memory the usage of "LoadLibrary" is required to load that DLL into the process's address space.
```c
typedef int (WINAPI* MessageBoxAFunctionPoinmter) ( // Constructing a new data type, that will represent MessageBoxA's function pointer
	HWND          hWnd,
	LPCSTR        lpText,
	LPCSTR        lpCaption,
	UINT          utype
);

void call() {
	// Retriebing MessageBox's address, and saving it ti 'pMessageBoxA' (MessageBoxA's function pointer)
	MessageBoxAFunctionPointer pMessageBoxA = (MessageBoxFunctionPointer)GetProcAddress(LoadLibraryA("user32.dll"), "MessageBoxA");
	if (pMessageBoxA != NULL) {
		// Calling MessageBox via its functionpointer if not null
		pMessageBoxA(NULL, "MessageBox's Text", "MessageBox's Caption", MB_OK);
	}
}
```
# Function Pointers
For the remainder of the course, the function pointer data types will have a naming convention that uses the WinAPI's name prefixed with "fn", which stands for "function pointer". For example the above "MessageBoxAFunctionPointer" data type will be represented as "fnMessageBoxA". This is used to maintain simplicity and improve clarity.
# Rundll32.exe
There are a couple of ways to run exported functions without using a programmatical method. One common technique is to use the "Rundll32.exe" binary. "Rundll32.exe" is a built-in Windows binary that is used to run an exorted function of a DLL file. To run an exported function use the following command.
```cmd
rundll32.exe <dllname>, <function exported to run>
```
For example, "User32.dll" exports the function "LockWorkStation" which locks the machine. To run the function, use the following command:
```cmd
rundll32.exe user32.dll,LockWorkStation
```
# Removing Precompiled Headers
When creating a DLL file using the Visual Studio Template, the DLL template will come with "framework.h", "pch.h", and "pch.cpp" which are known as *Precompiled Headers*, These are files used to make the project compilation faster for large projects. It is unlikely that these will be required in this situation and therrefore it is recommended to delete these files using the steps below.

First, create a new DLL file using Visual Studio's DLL template like previously shown.
![[create-dll-1.png]]

Next open the project and highlight "framework.h", "pch.h" and "pch.cpp" and press the delete key and select the "delete" option.

You will also need to remove "#include "pch.h"" from "dllmain.cpp" and replace it with "#include <Windows.h>"
![[create-dll-3-1.png]]
![[create-dll-3.png]]

After deleting the precompiled headers, the compiler's default settings must be changed t confirm that the precompiled headers should not be used in the project.
![[create-dll-4.png]]

Go to C/C++ > Precompiled Header
![[create-dll-5.png]]

Change the "Precompiled Header" option  to "Not using Precompiled Headers" and press "Apply".
![[create-dll-6.png]]

Finally, change the "dllmain.cpp" file to "dllmain.c". This is required since the provided code snippets in Maldev Academy uses C instead of C++. To compile a program, click Build > Build solution and a DLL will be created under the *Release* or *Debug* folder, depending on the compile configuration.
