# Structures
Structures or structs are user-defined data types that allow you to group related data items of different data types into a single unit.
- Can be used to store data related to a particular object
- Help organize large amounts of related data in a way that can be easily accessed and manipulated
- Each item is called a "member" or "element"
A common occurrence when working with the Windows API is that some APIs require a populated structure as input, while others will take a declared structure and populate it.
EXAMPLE
- THREADENTRY32 struct
```c
typedef struct tagTHREADENTRY32 {
	DWORD dwSize; // Member 1
	DWORD cntUsage; // Member 2
	DWORD th32ThreadID;
	DWORD th32OwnerProcessID;
	LONG tpBasePri;
	LONG tpDeltaPri;
	DWORD dwFalgs;
} THREADENTRY32;
```
## Declaring a structure
Structures are generally declared with the use of "typedef" keyword to give a structure and alias
EXAMPLE
- This structure is created with the name "_STRUCTURE_NAME" but "typedef" adds two other names:
	- "STRUCTURE_NAME"
	- "*PSTRUCTURE_NAME"
```c
typedef struct _STRUCTURE_NAME {
	// structure elements
} STRUCTURE_NAME, *PSTRUCTURE_NAME;
```
- The "STRUCTURE_NAME" alias refers to the structure name whereas "PSTRUCTURE_NAME" represents a pointer to that structure
	- Microsoft generally uses the "P" prefix to indicate a pointer type
## Initializing a structure
Initializing a structure will vary depending on whether one is initializing the actual structure type or a pointer to the structure.
EXAMPLE (continuing on the previous example)
- Initializing a structure is the same when using "_STRUCTURE_NAME" or "STRUCTURE_NAME"
```c
STRUCTURE_NAME     struct1 = {0}; // The '{0}' part, is used to initialize all the elements of struct1 to zero
// OR
struct _STRUCTURE_NAME     struct2 = {0}; // The '{0}' part, is used to initialize all the elements of struct to zero
```
- This is different when initializing the structure pointer "PSTRUCTURE_NAME"
```c
PSTRUCTURE_NAME structpointer = NULL;
```
## Initializing and accessing structures members
A structure's members can be initialized either directly through the structure or indirectly through a pointer to the structure.
EXAMPLE
- The structure "struct1" has 2 members "ID" and "Age" initialized directly via the dot operator (.)
```c
typedef struct _STRUCTURE_NAME {
	int ID;
	int Age;
} STRUCTURE_NAME, *PSTRUCTURE_NAME;

STRUCTURE_NAME struct1 = {0}; // Initialize all elements of struct1 to zero
struct1.ID = 1470; //Initialize the ID element
struct1.Age = 34; // Initialize the Age element
```
Another way to initialize the members is using *designated initializer syntax* where one can specify which members of the structure to initialize
EXAMPLE
```c
typedef struct _STRUCTURE_NAME {
	int ID;
	int Age;
} STRUCTURE_NAME, *PSTRUCTURE_NAME;

STRUCTURE_NAME struct1 = { .ID = 1470, .Age = 34 }; // Initialize bot the ID and Age elements
```
On the other hand, accessing and initializing a structure through its pointer is done via  the arrow operator (->)
EXAMPLE
```c
typedef struct _STRUCTURE_NAME {
	int ID;
	int Age;
} STRUCTURE_NAME, *PSTRUCTURE_NAME;

STRUCTURE_NAME struct1 = { .ID = 1470, .Age = 34 };

PSTRUCTURE_NAME structpointer = &struct1; // structpointer is a pointer to the 'struct1' structure

// Updating the ID member
structpointer->ID = 8765;
printf("The structure's ID member is now : %d \n", structpointer->ID);
```
- The arrow operator can be converted into dot format.
- EXAMPLE
	- structpointer->ID is equivelant to (*structpointer).ID
	- structurepointer is de-referenced and then accessed directly.
## Enumeration
The enum or enumeration data type is used to define a set of named constants. To create an enumeration, the "enum" keyword is uesed followed by the name of the enumeration and a list of identifiers, each of which represents a named constant.
The compiler automatically assigns values to the constants, starting with 0 and increasing by 1 for each subsequent constant.
EXAMPLE
- This example is the list of "Weekdays" which contains 7 constants
- Monday has a value of 0 , Tuesday has a value of 1 and so on
- Enum lists cannot be modified or accessed using the dot (.) operator
	- Instead, each element is accessed directly using its named constant value
```c
enum Weekdays {
	Monday,     // 0
	Tuesday,    // 1
	Wednesday,  // 2
	Thursday,   // 3
	Friday,     // 4
	Saturday,   // 5
	Sunday,     // 6
};

// Defining a "Weekdays" enum variable
enum Weekdays EnumName = Friday;     // 4

// Check the value of "EnumName"
switch (EnumName){
	case Monday:
		printf("Today is monday ! \n");
		break;
	case Tuesday:
		printf("Today is tuesday ! \n");
		break;
	case Wednesday:
		printf("Today is wednesday ! \n");
		break;
	case Thursday:
		printf("Today is thursday ! \n");
		break;
	case Friday:
		printf("Today is friday ! \n");
		break;
	case Saturday:
		printf("Today is saturday ! \n");
		break;
	case Sunday:
		printf("Today is sunday !\n")
		break;
	default:
		break;
}
```
## Union
In the C programming language, a union is a data type that permits the storage of various data types in the same memory location. Unions provide an efficient way to use a single memory location for multiple purposes.
Unions are not commonly used but can be seen in Windows-defined structures
EXAMPLE
- How to define a union in C
```c
union ExampleUnion {
	int   IntegerVar;
	char  CharVar;
	float FloatVar;
};
```
- "ExampleUnion" can store char, int, and float data types in the same memory location
- To access the members of a union in C, you can use the dot (.) operator similar to that used for structurres
- It's important to note that in a union, assigning a new value to any member will change the value of all other members as well because they share the same memory location to store their data
	- The memory allocated for a union is equal to the size of its largest member
## Bitwise operators
Bitwise operators are operators that manipulate the individual bits of a binary value, performing operations on each corresponding bit position.
### Operators
- Right shift
	- >>
- Left shift
	- <<
- Bitwise OR
	- |
- Bitwise AND
	- &
- Bitwise XOR
	- ^
- Bitwise NOT
	- ~
#### Right and left shift
The right shift (>>) and left shift (<<) operators are used to shift the bits of a binary number to the right and left by a specified number of positions, respectively

EXAMPLE
- Shifting right discards the rightmost number of bits by the specified value and zero bits of the same amount are inserted into the left.
	- Image shows 10100111 shifted to the right by 2, to become 00101001
![[shift_right.png]]
- Shifting left discards the leftmost bits and the same number of zero bits are inserted from the right handside
	- Image shows 10100111 shifted left by 2, to become 10011100
![[shift_left.png]]
####  Bitwise OR
The bitwise OR operation is a logical operation that involves two binary values at the bit level. it evaluates each bit of the first operand against the corresponding bit of the second operand, generating a new binary value.
The new binary value contains a 1 in any bit or position where either one or both of the corresponding bits in the original values are 1
EXAMPLE
- The following table represents the bitwise OR output with all the possible input bits.
![[bitwise_OR.png]]
#### Bitwise AND
The bitwise AND operation is a logical operation that involves two binary values at the bit level. 
This operation sets the bits of the new binary value to 1 only in the case where the corresponding bits of both input operands are 1
EXAMPLE
- The following table represents the bitwise AND output with all the possible input bits.
![[bitwise_AND.png]]
#### Bitwise XOR
The bitwise XOR operation (also known as exclusive OR) is a logical operation that involves two binary values at the bit level.
If only 1 of the bits is 1, the result in each position is 1. Conversly if both bits are 0 or 1, the output is 0
EXAMPLE
- The following table represents the bitwise XOR output with all the possible input bits.
![[bitwise_XOR.png]]
#### Bitwise NOT
The bitwise NOT operation takes one binary number and flips all its bits.
In other words, it changes all 0s to 1s and all 1s to 0s. 
EXAMPLE
- The following table represents the bitwise NOT output with all the possible input bits.
![[bitwise_NOT.png]]
## Passing by value
Passing by value is a method of passing arguments to a function where the argument is a copy of the object's value
- This means that when an argument is passed by a value, the value of the object is copied and the function can only modify its local copy of the object's value
	- Not the original object itself
EXAMPLE
```c
int add (int a, int b)
{
	int result = a + b;
	return result;
}

int main()
{
	int x = 5;
	int y = 10;
	int sum = add(x, y); // x and y are passed by value

	return 0;
}
```
## Passing by reference
Passing by reference is a method of passing arguments to a function where the argument is a pointer to the object, rather than a copy of the object's value
- This means that when an argument is passed by reference, the memory address of the object is passed insteadd of hte value of the object.
	- The function can then access and modify the object directly, without creating a local copy of the object. 
EXAMPLE
```c
void add(int *a, int *b, int *result)
{

	int A = *a; // A is now the same value of a passed in from the main function
	int B = *b; // B is now the same value of b passed in from the main function

	*result = B + A;
}

int main()
{
	int x = 5;
	int y = 10;
	int sum = 0;

	add(&x, &y, &sum);

	// 'sum' now is 15

	return 0;
}
```