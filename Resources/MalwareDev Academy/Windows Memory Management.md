## Virtual Memory & Paging
Memory in modern operating systems is not mapped directly to physical memory (i.e. RAM). Instead, virtual memory addresses are used by processes that are mapped to physical memory addresses.
There are several reasons for this but ultimately the goal is to save as much physical memory as possible.
Virtual memory may be mapped to physical memory but can also be stored on disk. With virtual memory addressing it becomes possible for multiple processes to share the same physical address while having a unique virtual memory address. Virtual memory relies on the concept of *memory paging* which divides memory into chunks of 4kb called "pages".
EXAMPLE
![[virtual-memory.png]]
### Page State
the pages residing within a processes's virtual address space can be in one of 3 states: 
1. Free
	1. The page is neither committed nor reserved
	2. The page is not accessible to the process
	3. The page is available to be reserved, committed, or simultaneously reserved and committed
	4. Attempting to read from or write to a free page can result in an access violation exception
2. Reserved
	1. The page has been reserved for future use
	2. The range of addresses cannot be used by other allocation functions
	3. The page is not accessible and has no physical storage associated with it.
	4. It is available to be committed
3. Committed
	1. Memory charges have been allocated from the overall size of RAM and paging files on disk.
	2. The page is accessible and access is controlled by one of the memory protection constants.
	3. The system initializes and loads each committed page into physical memory only during the first attempt to read or write to that page. 
	4. When the process terminates, the system releases the storage for committed pages
### Page protection options
Once the pages are committed, they need to have their protection option set.
the list of memory protection constants can be found below but so are some examples
- https://learn.microsoft.com/en-us/windows/win32/memory/memory-protection-constants
- PAGE_NOACCESS
	- Disables all access to the committed region of pages.
	- An attempt to read from, write to or execute the committed region will result in an access violation
- PAGE_EXECUTE_READWRITE
	- Enables read, write and execute
	- This is highly discouraged from being used and is generally an IoC because it's uncommon for memory to be both writable and executable at the same time.
- PAGE_READONLY
	- Enables read-only access to the committed region of pages.
	- An attempt to write to the committed region results in an access violation
### Memory Protection
Modern operating systems generally have built-in memory protections to thwart exploits and attacks. These are also important to keep in mind as they will likely be encountered when building or debugging malware.
- Data Execution Prevention (DEP)
	- DEP is a system level memory protection feature that is built into the operating system starting with Windows XP and Windows Server 2003.
	- If the page protection option is set to PAGE_READONLY, then DEP will prevent code from executing in that memory region.
- Address Space Layout Randomization (ASLR)
	- ASLR is a memory protection technique used to prevent the exploitation of memory corruption vulnerabilities.
	- ASLR randomly arranges the address space positions of key data areas of a process
		- Includes the base of the executable and the positions of the stack, heap and libraries
### x86 vs x64 Memory Space
When working with Windows processes, it's important to note whether the process is x86 or x64.
- x86 Processes have a smaller memory space of 4GB (0xFFFFFFFF)
- x64 Processes have a vastly larger memory space of 128TB (0xFFFFFFFFFFFFFFFF)
### Allocating memory example
This example goes through small code snippits to better understand how you can interact with Windows memory via C functions and Windows APIs. 
The first step in interacting with memory is allocating memory.
EXAMPLE
- This demonstrates several ways to allocate memory which is essentially reserving a memory inside the running process
```c
// Allocating a memory buffer of *100* bytes

// Method 1 - Using malloc()
PVOID pAddress = malloc(100);

// Method 2 - Using HeapAlloc()
PVOID pAddress = HeapAlloc(GetProcessHeap(), 0, 100);

// Method 3 - Using LocalAlloc()
PVOID pAddress = LocalAlloc(LPTR, 100);
```
Memory allocation functions return the *base address* which is simply a pointer to the beginning of the memory block that was allocated. 
- Using the snippits above "pAddress" will be the base address off the memory block that was allocated
	- Using this pointer several actions can be taken such as reading, writing and executing
	- The type of actions that can be performed will depend on the protection assigned to the allocated memory region.
EXAMPLE
- This shows what pAddress looks like under the debugger
![[mmgt_debug.png]]
When memory is allocated, it may either be empty or contain random data. 
Some memory allocation functions provide an option to zero out the memory region during the allocation process.
![[mmgt_zero.png]]
### Writing to memory example
